# vim: syntax=python expandtab
# coding: utf-8

"""
Compute coverage of (weighted) genomic fragments

For usage, include this in your workflow.

Expects a global variable config
(see https://bitbucket.org/johanneskoester/snakemake/wiki/Documentation#markdown-header-configuration)
of at least the
following structure, assuming that the desired reference sequence is some genome
to be found under the given path, and two units A and B have been sequenced with Illumina, 
the first paired and the second single end:

In addition the variable CODE_BASE should be defined with the pathname to the topdirectory containing the code of the pipeline

OUTDIR: "SuRE-pipelineOutput_r2Only_LP161229"

cDNA:
  OUTDIR:
    "cDNA"
  SAMPLES:
    A:
      - A.fastq
    B:
      - B.fastq

plDNA:
  OUTDIR:
    "plDNA"
  SAMPLES:
    C:
      - C.fastq
    D:
      - D.fastq

"""


__author__ = "Ludo Pagie"
__license__ = "MIT"

import os.path
from collections import ChainMap

CODE_BASE_BED2COV=os.path.join(CODE_BASE, "bed2coverage/")

BED2COVERAGE        = os.path.join(CODE_BASE_BED2COV, "_bed2coverage.bash")
MERGE_COVERAGE_CHRS = os.path.join(CODE_BASE_BED2COV, "merge-bigwig.py")
COVERAGE2NORM       = os.path.join(CODE_BASE_BED2COV, "normSuRE_cov_bigwig.py")
MERGE_REPLICATE_BW  = os.path.join(CODE_BASE_BED2COV, "addBigwigsScale.py")

# a iPCR_TARGETS=expand(os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz"), c=CHR_TARGET+CHR_AVAIL)

OUTDIR=config["OUTDIR"]
ASSEMBLY=config["ASSEMBLY"]
# determine files for output
EXT=[".cov.bw", ".cov.plus.bw", ".cov.minus.bw"]
EXTFLAT=[".covflat.bw", ".covflat.plus.bw", ".covflat.minus.bw"]

if config['cDNA']["SAMPLES"] is None:
  OUTFILES_cDNA=[];
else:
#   OUTFILES_cDNA  = [os.path.join(OUTDIR, config["cDNA"]["OUTDIR"], s, s+e) for s in config['cDNA']["SAMPLES"] for e in EXT]
  # OUTFILES_cDNA = expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_{c}{e}"), s=config['cDNA']["SAMPLES"], c=CHR_TARGET+CHR_AVAIL, e=EXT+EXTFLAT)
  OUTFILES_cDNA = expand(os.path.join(config["OUTDIR"],"coverage", "cDNA", "{s}", "{s}_{c}{e}"), s=config['cDNA']["SAMPLES"], c=CHR_TARGET+CHR_AVAIL, e=EXT+EXTFLAT)

# if config["plDNA"]["SAMPLES"] is None:
#   OUTFILES_plDNA=[]
# else:
# #  OUTFILES_plDNA  = [os.path.join(OUTDIR, config["plDNA"]["OUTDIR"], s, s+e) for s in config['plDNA']["SAMPLES"] for e in EXT+EXTFLAT]
#   OUTFILES_plDNA = expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_{c}{e}"), s=config['plDNA']["SAMPLES"], c=CHR_TARGET+CHR_AVAIL, e=EXT+EXTFLAT)

# OUTFILES_iPCR = [os.path.join(OUTDIR, config["iPCR"]["OUTDIR"], "iPCR"+e) for e in (EXT+EXTFLAT)]
# OUTFILES_iPCR = expand(os.path.join(iPCR_OUTDIR, "iPCR_{c}{e}"), c=CHR_TARGET+CHR_AVAIL, e=EXT+EXTFLAT)
OUTFILES_iPCR = expand(os.path.join(config["OUTDIR"], "coverage","iPCR", "iPCR_{c}{e}"), c=CHR_TARGET+CHR_AVAIL, e=EXT+EXTFLAT)
if OUTFILES_iPCR is None:
  OUTFILES_iPCR=[]
# OUTFILES      = OUTFILES_cDNA + OUTFILES_plDNA + OUTFILES_iPCR
OUTFILES      = OUTFILES_cDNA + OUTFILES_iPCR
# print("OUTFILES=", OUTFILES, "\n")

NORM_EXT=[e.replace("cov","norm") for e in EXT+EXTFLAT]
OUT_NORM_FILES=expand(os.path.join(config["OUTDIR"],"coverage", "cDNA", "{s}", "{s}{e}"), s=config['cDNA']["SAMPLES"], e=NORM_EXT)
OUT_MERGED_NORM_FILES=expand(os.path.join(config["OUTDIR"],"coverage", "{s}{e}"), s=config['cDNA']["REPLICATES"], e=NORM_EXT)

print(OUT_MERGED_NORM_FILES)

if ASSEMBLY == "hg19":
  CHROMSIZES="/home/ludo/DATA/local/data/genomes/hg19/hg19.chrom.sizes"
elif ASSEMBLY == "criGri1":
  CHROMSIZES="/home/NFS/users/l.pagie/data/genomes/criGri1/criGri1.chrom.sizes"
elif ASSEMBLY == "SL3":
  CHROMSIZES="/DATA/usr/ludo.gx/projects/LP180830_tomato_BAC/data/LP180830_SL3_std-ref-seq/SL3.chromsizes_LP180916"


rule bed2coverage:
  input:
    OUTFILES , OUT_NORM_FILES, OUT_MERGED_NORM_FILES
  output:
    temp(touch("bed2coverage.done"))

rule _bed2coverage_chr:
  input:
    # os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz")
    expand(os.path.join(config["OUTDIR"], "count_tables", "11_sorted", "{ass}", "{{c}}.bedpe.gz"), ass=['paternal','maternal','equal']) 
  output:
    all="{type}/{sample}/{sample}_{c}.cov.bw",
    plus="{type}/{sample}/{sample}_{c}.cov.plus.bw",
    minus="{type}/{sample}/{sample}_{c}.cov.minus.bw",
    flat="{type}/{sample}/{sample}_{c}.covflat.bw",
    flatplus="{type}/{sample}/{sample}_{c}.covflat.plus.bw",
    flatminus="{type}/{sample}/{sample}_{c}.covflat.minus.bw"
  params:
    s="{sample}"
  resources:
    ram=50
  conda: CONDA_ENV
  shell:
    " export BED2COVERAGE_EXE={CODE_BASE_BED2COV}'bed2coverage' ; "
    " {BED2COVERAGE} -a {output.all} -p {output.plus} -m {output.minus} -c {params.s} -s {CHROMSIZES} {input} ; "

rule merge_coverage_chrs_cdna:
  wildcard_constraints:
#    # this rule should not match to "..._norm.bw" files; exclude this using the constraints
#    # e="/^((?!_norm).)*$/"
    e=".cov.*"
  # merge cDNA coverage files over all chromosomes 
  input:
    expand(os.path.join(config["OUTDIR"],"coverage", "cDNA", "{{s}}", "{{s}}_{c}{{e}}.bw"), c=CHR_TARGET+CHR_AVAIL)
  output:
    os.path.join(config["OUTDIR"],"coverage", "cDNA", "{s}", "{s}{e}.bw")
  resources:
    ram=64
  conda: CONDA_ENV
  shell:
    "python {MERGE_COVERAGE_CHRS} --inbw {input} --outfname {output}"

rule merge_coverage_chrs_ipcr:
  wildcard_constraints:
#    # this rule should not match to "..._norm.bw" files; exclude this using the constraints
#    # e="/^((?!_norm).)*$/"
    e=".cov.*"
  input:
    expand(os.path.join(config["OUTDIR"],"coverage", "iPCR", "iPCR_{c}{{e}}.bw"), c=CHR_TARGET+CHR_AVAIL)
  output:
    os.path.join(config["OUTDIR"],"coverage", "iPCR", "iPCR{e}.bw")
  resources:
    ram=64
  conda: CONDA_ENV
  shell:
    # "# merge iPCR coverage files over all chromosomes"
    "python {MERGE_COVERAGE_CHRS} --inbw {input} --outfname {output}"

rule coverage2norm:
  wildcard_constraints:
    # this rule should match empty string, or ".plus" or ".minus". empty string
    # is by default not allowed as wildcard, so set the constraint explicitly
    # here:
    e=".*"
  input:
    cdna=os.path.join(config["OUTDIR"],"coverage", "cDNA", "{s}", "{s}.cov{e}.bw"),
    ipcr=os.path.join(config["OUTDIR"],"coverage", "iPCR", "iPCR.cov{e}.bw")
  output:
    os.path.join(config["OUTDIR"],"coverage", "cDNA", "{s}", "{s}.norm{e}.bw")
  resources:
    ram=35
  conda: CONDA_ENV
  shell:
    # "# norm cDNA sample based on iPCR sample"
    "python {COVERAGE2NORM} --out {output} --cdna {input.cdna} --input {input.ipcr}"


def get_replicates(wildcards):
  return([ os.path.join(config["OUTDIR"],"coverage", "cDNA", s, s+wildcards.e)  for s in config["cDNA"]["REPLICATES"][wildcards.r] ])

rule merge_replicate_bw:
  wildcard_constraints:
    e="\.norm.*bw"
  input:
    get_replicates
  output:
    os.path.join(config["OUTDIR"],"coverage", "{r}{e}")
  resources:
    ram=35
  params:
    chrs=["\"chr"+str(c)+"\"" for c in config["CHR_TARGET"]]
  shell:
    "python {MERGE_REPLICATE_BW} --bigwigs {input} --outfname {output} -v --chrs {params.chrs}"


# rule _bed2coverage:
#   input:
#     os.path.join(OUTDIR, "SuRE-counts.txt.gz")
#   output:
#     all="{type}/{sample}/{sample}.cov.bw",
#     plus="{type}/{sample}/{sample}.cov.plus.bw",
#     minus="{type}/{sample}/{sample}.cov.minus.bw",
#     flat="{type}/{sample}/{sample}.covflat.bw",
#     flatplus="{type}/{sample}/{sample}.covflat.plus.bw",
#     flatminus="{type}/{sample}/{sample}.covflat.minus.bw"
#   params:
#     s="{sample}"
#   resources:
#     ram=50
#   conda: CONDA_ENV
#   shell:
#     " export BED2COVERAGE_EXE={CODE_BASE_BED2COV}'bed2coverage' ; "
#     " {BED2COVERAGE} {input} {output.all} {output.plus} {output.minus} {params.s} {CHROMSIZES} ; "

