# vim: syntax=python expandtab
# coding: utf-8

import glob
import os.path
import sys
from itertools import compress
from os import listdir
import fnmatch
import inspect
import subprocess

# check if snakefile originates from a 'clean' git repos
snakefilename = inspect.getframeinfo(inspect.currentframe()).filename
repospath = os.path.dirname(os.path.abspath(snakefilename))
repos_state = subprocess.run('cd '+repospath+'; [ -z "$( git status --porcelain )" ] && exit 0 || exit 1', stdout=subprocess.PIPE, shell=True, universal_newlines=True)
if repos_state.returncode != 0:
        print("\nYour snakefile is modified relative to the git repos", file=sys.stderr)
        print("Either undo your changes, or commit them", file=sys.stderr)
        print("Aborting\n\n", file=sys.stderr)
        sys.exit("")

# set code_base directory and retrieve hash of git commit
CODE_BASE = os.path.join(repospath, "code")
repos_state = subprocess.run('cd '+repospath+'; git log --pretty=format:"%H" -n 1', stdout=subprocess.PIPE, shell=True, universal_newlines=True)
GIT_COMMIT_HASH = repos_state.stdout

# print pipeline VERSION to stdout
VERSIONFILE = os.path.join(CODE_BASE, "../", "VERSION")
with open(VERSIONFILE, 'r') as myfile:
    VERSION=myfile.read().replace('\n', '')
print ("SuRE-seq pipeline version: ", VERSION, "\n", "git commit hash: ", GIT_COMMIT_HASH, "\n\n")


# copy all parameters (for readability)
CONDA_ENV               = os.path.join(CODE_BASE, 'conda-env-sure.yml')
CONDA_ENV_PY2           = os.path.join(CODE_BASE, 'conda-env-py2.yml')
SAMTOOLS                = "samtools"
WASP_DIR                = os.path.join(CODE_BASE, "WASP/mapping")
PY2_WASP                = "PYTHONPATH=$PYTHONPATH:" + WASP_DIR + " python2.7 "
SNP_DIR                 = "/DATA/home/ludo/projects/LP140430_SureSeq_JvArensbergen/data/LP170210_SuRE42-45_1000Genomes/"
SPLITBAM                = "bam splitChromosome "
R                       = "/usr/bin/Rscript --vanilla"

cDNA_script             = os.path.join(CODE_BASE, "cDNA-plDNA-count-BC.bash")
iPCR_trim_script        = os.path.join(CODE_BASE, "iPCR-trim.bash")
iPCR_mapOnly_script     = os.path.join(CODE_BASE, "iPCR-map.bash")
iPCR_bam2bedpe_script   = os.path.join(CODE_BASE, "iPCR_bam_to_annotBed.py")
iPCR_single_QA_script   = os.path.join(CODE_BASE, "iPCR-single-QA.bash")
iPCR_merge_script       = os.path.join(CODE_BASE, "iPCR-merge-bedpe-Filter-BC-multi-pos.bash")
iPCR_merge_bedpe_smpls  = os.path.join(CODE_BASE, "merge_bedpe_over_samples.R")
iPCR_addBC2bedpe        = os.path.join(CODE_BASE, "iPCR_addBC2bedpe.py")
split_bedpe_script      = os.path.join(CODE_BASE, "split-bedpe2chr.sh")
merge_all_script        = os.path.join(CODE_BASE, "merge-iPCR-cDNA-plDNA.bash")
add_homozygous_baseIdentities_script = os.path.join(CODE_BASE, "add-homozygous-baseIndentities.bash")
ASSIGN_PARENT_SCRIPT    = os.path.join(CODE_BASE, "iPCR_assign_parent.py")

ADPTR_IPCR_FORW_SEQ     = config["ADPTR_IPCR_FORW_SEQ"]
ADPTR_IPCR_REV_SEQ      = config["ADPTR_IPCR_REV_SEQ"]
BOWTIE2_REFSEQ          = config["BOWTIE2_REFSEQ"]
NCORES                  = config["NCORES"]
OUTDIR                  = config["OUTDIR"]
ALLELE_SPECIFIC         = config["ALLELE_SPECIFIC"]
CHR_TARGET              = config["CHR_TARGET"]

CHR_ALL                 = ["chr"+str(i) for i in range(1,23)]+['chrX','chrY','chrM']
CHR_AVAIL=list(compress(CHR_ALL, [os.path.isfile(f) for f in expand(os.path.join(config["OUTDIR"], config["iPCR"]["OUTDIR"], "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz"), c=CHR_ALL)]))

cDNA_SAMPLES=config["cDNA"]["SAMPLES"]
if cDNA_SAMPLES is None:
  cDNA_SAMPLES={}
cDNA_FASTQ_DIR=config["cDNA"]["FASTQ_DIR"]
cDNA_OUTDIR=os.path.join(config["OUTDIR"], config["cDNA"]["OUTDIR"])
cDNA_TARGETS=expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys())

plDNA_SAMPLES=config["plDNA"]["SAMPLES"]
if plDNA_SAMPLES is None:
  plDNA_SAMPLES={}
plDNA_FASTQ_DIR=config["plDNA"]["FASTQ_DIR"]
plDNA_OUTDIR=os.path.join(config["OUTDIR"], config["plDNA"]["OUTDIR"])
plDNA_TARGETS=expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys())

iPCR_SAMPLES=config["iPCR"]["SAMPLES"]
if iPCR_SAMPLES is None:
  iPCR_SAMPLES={}
iPCR_SAMPLE2FILES={sample:[iPCR_SAMPLES[sample]["R1"],iPCR_SAMPLES[sample]["R2"]] for sample in iPCR_SAMPLES.keys()}
iPCR_FASTQ_DIR=config["iPCR"]["FASTQ_DIR"]
iPCR_OUTDIR=os.path.join(OUTDIR, config["iPCR"]["OUTDIR"])
BEDPE_FILES=expand(os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz"), s=iPCR_SAMPLES.keys())
iPCR_TARGETS=expand(os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz"), c=CHR_TARGET+CHR_AVAIL)

if (ALLELE_SPECIFIC is None) or (ALLELE_SPECIFIC == 0):
  GID = None
  SNP_DIR=""
  VCF_DIR=""
  print("processing in non-allele specific manner")
else:
  GID = config["GID"]
  if GID is None:
    sys.exit("ALLELE_SPECIFIC processing requested but no GID specified")
  if SNP_DIR is None:
    sys.exit("ALLELE_SPECIFIC processing requested but no SNP_DIR specified")
  VCF_DIR=SNP_DIR
  SNP_DIR=os.path.join(SNP_DIR, "SNPs")
  if not(os.path.exists(SNP_DIR)):
    sys.exit("GID is defined but SNP directory doesn't exist")
  print("reading SNPs from " + SNP_DIR)
  print("reading VCF from " + VCF_DIR)

include: os.path.join(CODE_BASE, "bed2coverage/bed2coverage.rule")

rule all:
  input:
    cDNA_TARGETS, plDNA_TARGETS, iPCR_TARGETS,
    "bed2coverage.done"
#    "QA.done"

rule assigned:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "03_assigned", "{s}_{pat}.bam"), s=config["iPCR"]["SAMPLES"].keys(), pat=['paternal','maternal','equal','ambiguous']) 

rule bedpe:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "06_bedpe", "{ass}","{s}_{c}.bedpe.gz"), 
           s=config["iPCR"]["SAMPLES"].keys(), 
           c=config["CHR_TARGET"],
           ass=['paternal','maternal','equal','ambiguous']) 

def bedpe_BC_equal_input(wildcards):
  return expand(os.path.join(iPCR_OUTDIR, "{s}", "07_bedpe_BC", "{ass}","{s}_{c}.bedpe.gz"), 
           s=config["iPCR"]["SAMPLES"].keys(), 
           c=config["CHR_TARGET"],
           ass=['equal']) 

def bedpe_BC_ambiguous_input(wildcards):
  return expand(os.path.join(iPCR_OUTDIR, "{s}", "07_bedpe_BC", "{ass}","{s}_{c}.bedpe.gz"), 
           s=config["iPCR"]["SAMPLES"].keys(), 
           c=config["CHR_TARGET"],
           ass=['ambiguous']) 

def bedpe_BC_paternal_input(wildcards):
  return expand(os.path.join(iPCR_OUTDIR, "{s}", "07_bedpe_BC", "{ass}","{s}_{c}.bedpe.gz"), 
           s=config["iPCR"]["SAMPLES"].keys(), 
           c=config["CHR_TARGET"],
           ass=['paternal']) 

def bedpe_BC_maternal_input(wildcards):
  return expand(os.path.join(iPCR_OUTDIR, "{s}", "07_bedpe_BC", "{ass}","{s}_{c}.bedpe.gz"), 
           s=config["iPCR"]["SAMPLES"].keys(), 
           c=config["CHR_TARGET"],
           ass=['maternal']) 

rule bedpe_BC_equal:
  input: bedpe_BC_equal_input

rule bedpe_BC_ambiguous:
  input: bedpe_BC_ambiguous_input

rule bedpe_BC_paternal:
  input: bedpe_BC_paternal_input

rule bedpe_BC_maternal:
  input: bedpe_BC_maternal_input

rule bedpe_BC:
  input: bedpe_BC_equal_input, bedpe_BC_ambiguous_input, bedpe_BC_paternal_input, bedpe_BC_maternal_input

rule bedpe_merged_smpls:
  input: expand(os.path.join(iPCR_OUTDIR, "samples_merged", "08_bedpe_merged", "{ass}", "{c}.bedpe.gz"), c=config["CHR_TARGET"], ass=['paternal','maternal','equal','ambiguous']) 

rule QA:
  input:
    expand(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"), s=iPCR_SAMPLES.keys())
  output:
    temp(touch("QA.done"))

rule cDNA:
  input:
    lambda wildcards: [os.path.join(cDNA_FASTQ_DIR, f) for f in cDNA_SAMPLES[wildcards.s]]
  output:
    os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz")
  params:
    dir=os.path.join(cDNA_OUTDIR,"{s}"),
    adpt_seq=config["ADPT_SEQ"],
    basename="{s}"
  conda: CONDA_ENV
  shell:
    "{cDNA_script} -l -b '{params.basename}' -o '{params.dir}' -a '{params.adpt_seq}' {input}"

rule plDNA:
  input:
    lambda wildcards: [os.path.join(plDNA_FASTQ_DIR, f) for f in plDNA_SAMPLES[wildcards.s]]
  output:
    os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz")
  params:
    dir=os.path.join(plDNA_OUTDIR,"{s}"),
    adpt_seq=config["ADPT_SEQ"],
    basename="{s}"
  conda: CONDA_ENV
  shell:
    "{cDNA_script} -l -b '{params.basename}' -o '{params.dir}' -a '{params.adpt_seq}' {input}"

rule iPCR_trim:
  input:
    lambda wildcards: [os.path.join(iPCR_FASTQ_DIR, f) for f in iPCR_SAMPLE2FILES[wildcards.s]]
  output:
    os.path.join(iPCR_OUTDIR,"{s}","01_fastq_trimmed","{s}_forw.fastq.gz"),
    os.path.join(iPCR_OUTDIR,"{s}","01_fastq_trimmed","{s}_rev.fastq.gz"),
    os.path.join(iPCR_OUTDIR,"{s}","01_fastq_trimmed","{s}_forw.info.gz")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}", "01_fastq_trimmed"),
    cutmotif=lambda wildcards: iPCR_SAMPLES[wildcards.s]["CUTMOTIF"],
    forwAdaptr=ADPTR_IPCR_FORW_SEQ,
    revAdaptr=ADPTR_IPCR_REV_SEQ,
    basename="{s}"
  conda: CONDA_ENV
  shell:
    "{iPCR_trim_script} -o '{params.dir}' -l -d '{params.cutmotif}' -b '{params.basename}' -f '{params.forwAdaptr}' -r '{params.revAdaptr}' -c {input}; "
    "parallel gzip ::: '{params.dir}'/*fastq '{params.dir}'/*info"

rule iPCR_map_bowtie2_paired_end:
  # map PE reads in 2 fastq files to either paternal or maternal genome
  # input: 2 fastq files with PE read pairs
  # output: single bam file with alignments for *all* reads, sorted long readID
  # note: bowtie2 index file selected based on config, genomeID, and parent
  input:
    os.path.join(iPCR_OUTDIR,"{s}","01_fastq_trimmed","{s}_forw.fastq.gz"),
    os.path.join(iPCR_OUTDIR,"{s}","01_fastq_trimmed","{s}_rev.fastq.gz")
  output:
    os.path.join(iPCR_OUTDIR,"{s}","02_mapped","{s}_{p}.bam")
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","02_mapped"),
    stats=os.path.join(iPCR_OUTDIR,"{s}","{s}_{p}.stats"),
    basename="{s}_{p}",
    refseq=lambda wildcards: os.path.join(config["BOWTIE2_INDEX_DIR"], config["BOWTIE2_PARENTAL"][config["GID"]][wildcards.p]),
    maxInsert=config["MAX_INSERT_LENGTH"]
  threads: 
    5
  resources:
    ram=5
  conda: CONDA_ENV
  priority: 50
  shell:
    "{iPCR_mapOnly_script} -o '{params.dir}' -l -n {threads} -t $PWD/'{params.stats}' -b '{params.basename}' -m '{params.maxInsert}' -s '{params.refseq}' -c {input}"

rule iPCR_assign_parent:
  # assign each PE read pair, aligned on paternal and maternal genome, to
  # either paternal, maternal, equal, or ambiguous
  # input: 2 bam files; each containing all read pairs mapped to either
  # paternal and maternal genome
  # output: 4 bam files, with each PE read pair occuring in at most one, some
  # read pairs are discarded all together
  input:
    paternal=os.path.join(iPCR_OUTDIR,"{s}","02_mapped","{s}_paternal.bam"),
    maternal=os.path.join(iPCR_OUTDIR,"{s}","02_mapped","{s}_maternal.bam")
  output:
    # temp(os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_paternal.bam")),
    # temp(os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_maternal.bam")),
    # temp(os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_equal.bam")),
    # temp(os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_ambiguous.bam"))
    os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_paternal.bam"),
    os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_maternal.bam"),
    os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_equal.bam"),
    os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}_ambiguous.bam")
  conda: CONDA_ENV
  params:
    dir=os.path.join(iPCR_OUTDIR,"{s}","03_assigned"),
    basename=os.path.join(iPCR_OUTDIR,"{s}","03_assigned","{s}")
  threads: 4
  shell:
    "mkdir -p '{params.dir}' ; "
    "python {ASSIGN_PARENT_SCRIPT} --bp {input.paternal} --bm {input.maternal} --basename '{params.basename}' ; "


rule iPCR_coordsort_bam:
  # Sort input bam files along genomic coordinates
  # input: bam files after assignment to paternal/maternal/equal/ambiguous
  # output: bam files for splitting along chromosome
  input:
    os.path.join("{path}","{smpl}","03_assigned","{smpl}_{assign}.bam")
  output:
    bam=temp(os.path.join("{path}","{smpl}","04_sort_after_assign","{smpl}_{assign}.bam")),
    bai=temp(os.path.join("{path}","{smpl}","04_sort_after_assign","{smpl}_{assign}.bam.bai"))
  threads: 4
  conda: CONDA_ENV
  resources:
    ram=40
  shell:
    "samtools sort -o {output.bam} -@ {threads} -m 20G -T {output.bam} {input} ; "
    "samtools index {output.bam} ; "


rule iPCR_templateBAM:
  # generate empty bam files for each chromosome, containing only the
  # appropriate header info
  # input: corresponding bam file containing alignments for whole-genome
  # output: bam files containing only header for all chromosomes
  input:
    input=os.path.join("{path}","{smpl}","04_sort_after_assign","{smpl}_{assign}.bam"),
  output:
    template=os.path.join("{path}","{smpl}","05_split_bam","{assign}","{smpl}_{chr}_template.bam")
  conda: CONDA_ENV
  shell:
    "samtools view -H -b {input} -o {output}"

rule iPCR_splitBAM:
  # split input bam file along chromosome; this enables further paralellisation
  # down stream.
  # INPUT: whole-genome bam file, plus bam file "templates" for all chromosomes
  # which only contain header info. The latter bam files are generated to catch
  # cases that a chromsome doesn't contain any data, in which case an 'empty'
  # bam file already exists.
  # OUTPUT: bam files for all chromosomesi, sorted along readID.
  # NOTE: the chromosomes are names 'number_parent', eg. 04_paternal,
  # 12_maternal. Data is already assigned to different classes; paternal,
  # maternal, equal, ambiguous. All alignments, except for the
  # maternal-assigned alignments, are aligned to paternal genome. In this rule
  # the parental extension of the chromosome name is removed from the bam
  # filename. The chromosome names used in the bam file still contain the
  # parental extension. 
  input:
    input=os.path.join("{path}","{smpl}","04_sort_after_assign","{smpl}_{ass}.bam"),
    template=expand(os.path.join("{{path}}","{{smpl}}","05_split_bam","{{ass}}","{{smpl}}_{chr}_template.bam"), chr=config["CHR_TARGET"])
  output:
    expand(os.path.join("{{path}}","{{smpl}}","05_split_bam","{{ass}}","{{smpl}}_{chr}.bam"), chr=config["CHR_TARGET"])
  params:
    noext=os.path.join("{path}","{smpl}","05_split_bam","{ass}","{smpl}_")
  conda: CONDA_ENV
  shell:
    "rename -f -e 's/_template//' {input.template} ; "
    "{SPLITBAM} --in {input.input} --out '{params.noext}'; "
    "rename -f -e 's/_[pm]aternal//' '{params.noext}'*bam ; "
    "for f in '{params.noext}'*bam; do mv $f ${{f}}.tmp; samtools sort -n -o ${{f}} ${{f}}.tmp; rm -f ${{f}}.tmp; done ; "

def vcf_chr(wildcards):
  ass = "maternal" if wildcards.ass == "maternal" else "paternal"
  vcf = [os.path.join(config['VCF_DIR'], config['VCF_PARENTAL'][config['GID']][ass])]
  return [v.replace("_CHR_","_%s_" % wildcards.c) for v in vcf]

rule iPCR_bam2bedpe:
  # reformat aligned read pairs to bedpe-like data, assign SNP-annotation to each bedpe-fragment
  # INPUT: bam file, vcf file, determined using above input function (note that
  # all bam files, except the maternal  one, are aligned along paternal genome)
  # OUTPUT: compressed bedpe-like file
  input:
    bam=os.path.join("{path}","{smpl}","05_split_bam","{ass}","{smpl}_{c}.bam"),
    vcf = vcf_chr
  output:
    os.path.join("{path}", "{smpl}", "06_bedpe", "{ass}", "{smpl}_{c}.bedpe.gz")
  params:
    patmat="maternal" if "{ass}" == "maternal" else "paternal",
  conda: CONDA_ENV
  resources:
    ram=40
  shell:
    "python {iPCR_bam2bedpe_script} -b {input.bam}  -v {input.vcf} -o {output} -p '{params.patmat}' ; "

rule addBC2bedpe:
  # associate barcode sequence (from info file generated dusing fastq trimming)
  # to SuRE fragments (from bedpe file) via readID in both files.
  # INPUT: bedpe file from rule iPCR_bam2bedpe, info file from rule iPCR_trim
  # OUTPUT: compressed bedpe-like file
  input:
    bedpe    = os.path.join("{path}", "{smpl}", "06_bedpe", "{ass}", "{smpl}_{c}.bedpe.gz"),
    info     = os.path.join(iPCR_OUTDIR,"{smpl}","01_fastq_trimmed","{smpl}_forw.info.gz")
  output:
    bedpe_BC = os.path.join("{path}", "{smpl}", "07_bedpe_BC", "{ass}", "{smpl}_{c}.bedpe.gz"),
    log      = os.path.join("{path}", "{smpl}", "07_bedpe_BC", "{ass}", "{smpl}_{c}.log"),
    stats    = os.path.join("{path}", "{smpl}", "07_bedpe_BC", "{ass}", "{smpl}_{c}.stats"),
  conda: CONDA_ENV
  resources:
    ram=30
  shell:
    "python {iPCR_addBC2bedpe} --bedpe {input.bedpe} --info {input.info} --out {output.bedpe_BC} --log {output.log} --stats {output.stats}"


def iPCR_map_input(wildcards):
  if (ALLELE_SPECIFIC):
    return os.path.join(iPCR_OUTDIR,wildcards.s,"merge",wildcards.s+"_"+wildcards.c+".keep.merge.bam") 
  else:
    return os.path.join(iPCR_OUTDIR,wildcards.s,"map1_sort",wildcards.s+"_"+wildcards.c+".bam")

rule iPCR_merge_bedpe:
  input:
    # expand(os.path.join(iPCR_OUTDIR, "{s}", "{s}_{{c}}.bedpe.gz"), s=iPCR_SAMPLES.keys())
    expand(os.path.join("{{path}}", "{smpl}", "07_bedpe_BC", "{{ass}}", "{smpl}_{{c}}.bedpe.gz"), smpl=config["iPCR"]["SAMPLES"].keys())
  output:
    bedpe = os.path.join("{path}", "samples_merged", "08_bedpe_merged", "{ass}", "{c}.bedpe.gz"),
    log = os.path.join("{path}", "samples_merged", "08_bedpe_merged", "{ass}", "{c}.log")
  resources:
    ram=40
  threads: 4
#  params:
#    dir=os.path.join(iPCR_OUTDIR, "bed-annot")
#   conda: CONDA_ENV
#  script:
#    iPCR_merge_bedpe_smpls
  shell:
    "{R} {iPCR_merge_bedpe_smpls} {output.bedpe} {output.log} {input}"

rule iPCR_annot_WASP:
  input:
    bedpe=os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}.txt.gz"),
    snpdir=SNP_DIR,
    vcf=lambda wildcards: [os.path.join(VCF_DIR,f) for f in listdir(VCF_DIR) if fnmatch.fnmatch(f, "ALL."+wildcards.c+".phase3_shapeit2_mvncall_integrated_*.20130502.genotypes_HG02601_NA18983_HG01241_HG03464_LP170414.vcf.gz")]
  output:
    os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_{c}_SNPannot.txt.gz")
  resources:
    ram=25
  params:
    gid=GID
  conda: CONDA_ENV_PY2
  shell:
    "{PY2_WASP} {WASP_DIR}/annotate_bedpe_LP170516.py --snp_dir {input.snpdir} {input.bedpe} | sort -k6 -S 20G | gzip -c > {output}.tmp ; "
    "{add_homozygous_baseIdentities_script} {input.vcf} {output}.tmp '{params.gid}' | gzip -c > {output} ;  "
    "rm -f {output}.tmp"

def merge_all_input(wildcards):
  if (ALLELE_SPECIFIC):
    return os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_"+wildcards.c+"_SNPannot.txt.gz")
  else:
    return os.path.join(iPCR_OUTDIR, "bed-annot", "iPCR-combined-bedpe_"+wildcards.c+".txt.gz")

rule merge_all:
  input:
    iPCR=merge_all_input,
    cDNA=expand(os.path.join(cDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=cDNA_SAMPLES.keys()),
    plDNA=expand(os.path.join(plDNA_OUTDIR, "{s}", "{s}_trimmed_table.txt.gz"), s=plDNA_SAMPLES.keys()),
  output:
    out=os.path.join(OUTDIR, "SuRE-counts_{c}.txt.gz")
  params:
    iPCR=merge_all_input
  conda: CONDA_ENV
  shell:
    "{merge_all_script} -l -i {input.iPCR} -o {OUTDIR} -d {output.out} {input.cDNA} {input.plDNA} ; "

rule iPCR_single_QA:
  input:
    os.path.join(iPCR_OUTDIR, "{s}", "{s}.bedpe.gz")
  output:
    touch(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"))
  params:
    basename="{s}",
    outdir=os.path.join(iPCR_OUTDIR,"{s}")
  conda: CONDA_ENV
  shell:
    "{iPCR_single_QA_script} -l -b '{params.basename}' -o '{params.outdir}'"

#rule iPCR_single_QA:
#  input:
#    expand(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.{s}.done"), s=iPCR_SAMPLES.keys())
#  output:
#    temp(touch(os.path.join(iPCR_OUTDIR, "{s}", "iPCR_single_QA.done")))

